# This file is generated by https://github.com/adoyle-h/lobash
# Author: ADoyle <adoyle.h@gmail.com>
# License: Apache License Version 2.0
# Version: 0.4.0
# Prefix: dotfiles_l.
# Bash Minimum Version: 4.4
# Included Modules: array_include array_include.s ask ask_input ask_with_cancel basename basename.p benchmark choose compose count_file_lines count_files count_lines.p cur_function_name cursor_col cursor_pos cursor_row date detect_os dirname dirname.p echo echo_array echo_screen end_with end_with.s extname extname.p first has has.s has_not has_not.s hex_to_rgb hostname if inc is_array is_array.s is_bash is_bash.s is_dir is_dir.s is_executable is_executable.s is_executable_file is_executable_file.s is_falsy is_falsy.s is_file is_file.s is_float is_float.s is_integer is_integer.s is_link is_link.s is_number is_number.s is_readable is_readable.s is_truthy is_truthy.s is_ubuntu is_writable is_writable.s join keys last lower_case lower_case.p lower_first lower_first.p match match_list normalize normalize.p not.s not.s.p now now_s parse_params pwd random repeat rgb_to_hex sleep sort split start_with start_with.s str_include str_include.s str_len str_size sub trace_count trace_end trace_stack trace_start trace_time trap_error trim trim.p trim_color trim_color.p trim_end trim_end.p trim_start trim_start.p union_array upper_case upper_case.p upper_first upper_first.p with_ifs xdg_config_home

######################## Lobash Internals ########################

_lobash.0_4_0_48361424_25787_detect_os() {
  local kernel_name
  kernel_name="$(uname -s)"

  case "$kernel_name" in
    "Darwin")                         echo MacOS ;;
    "SunOS")                          echo Solaris ;;
    "Haiku")                          echo Haiku ;;
    "MINIX")                          echo MINIX ;;
    "AIX")                            echo AIX ;;
    "IRIX"*)                          echo IRIX ;;
    "FreeMiNT")                       echo FreeMiNT ;;
    "Linux" | "GNU"*)                 echo Linux ;;
    *"BSD" | "DragonFly" | "Bitrig")  echo BSD ;;
    "CYGWIN"* | "MSYS"* | "MINGW"*)   echo Windows ;;
    *)                                echo Unknown_OS "$kernel_name" ;;
  esac
}



[[ -n ${_LOBASH_0_4_0_48361424_25787_INTERNAL_FUNC_PREFIX:-} ]] && return

readonly _LOBASH_0_4_0_48361424_25787_INTERNAL_FUNC_PREFIX=_lobash.
readonly _LOBASH_0_4_0_48361424_25787_INTERNAL_CONST_PREFIX=_LOBASH_
readonly _LOBASH_0_4_0_48361424_25787_PRIVATE_FUNC_PREFIX=_l.
readonly _LOBASH_0_4_0_48361424_25787_PRIVATE_CONST_PREFIX=_L_
readonly _LOBASH_0_4_0_48361424_25787_PUBLIC_FUNC_PREFIX=l.
readonly _LOBASH_0_4_0_48361424_25787_PUBLIC_CONST_PREFIX=L_

readonly _LOBASH_0_4_0_48361424_25787_PREFIX=dotfiles_l.
readonly _LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH=2
readonly _LOBASH_0_4_0_48361424_25787_MIN_BASHVER=4.4

readonly _LOBASH_0_4_0_48361424_25787_OS=$(_lobash.0_4_0_48361424_25787_detect_os)

_lobash.0_4_0_48361424_25787_is_bash() {
  [[ -n "${BASH_VERSION:-}" ]]
}

_lobash.0_4_0_48361424_25787_check_os() {
  if [[ ! $_LOBASH_0_4_0_48361424_25787_OS =~ ^(Linux|MacOS|BSD)$ ]]; then
    echo "Not support current system: $_LOBASH_0_4_0_48361424_25787_OS" >&2
    return 5
  fi
}

_lobash.0_4_0_48361424_25787_check_shell() {
  if ! _lobash.0_4_0_48361424_25787_is_bash; then
    echo 'Lobash only work in Bash.' >&2
    return 6
  fi
}

_lobash.0_4_0_48361424_25787_check_supported_bash_version() {
  local info
  read -r -d '.' -a info <<< "$_LOBASH_0_4_0_48361424_25787_MIN_BASHVER"
  if (( BASH_VERSINFO[0] < info[0] )) \
    || ( (( BASH_VERSINFO[0] == info[0] )) && (( BASH_VERSINFO[1] < info[1] )) ); then
    echo "Bash $BASH_VERSION is not supported. Upgrade your Bash to $_LOBASH_0_4_0_48361424_25787_MIN_BASHVER or higher version." >&2
    return 7
  fi
}

_lobash.0_4_0_48361424_25787_check_support() {
  _lobash.0_4_0_48361424_25787_check_os
  _lobash.0_4_0_48361424_25787_check_shell
  # _lobash.0_4_0_48361424_25787_check_supported_bash_version
}

_lobash.0_4_0_48361424_25787_check_support

_lobash.0_4_0_48361424_25787_dirname() {
  local str=${1:-}
  [[ $str == '/' ]] && echo '/' && return 0
  [[ $str =~ ^'../' ]] && echo '.' && return 0
  [[ ! $str =~ / ]] && echo '.' && return 0

  printf '%s\n' "${str%/*}"
}

_lobash.0_4_0_48361424_25787_with_IFS() {
  local IFS=$1
  shift
  eval "$@"
}

######################## Private Methods ########################


l.0_4_0_48361424_25787_array_include() {
  local array_name=$1
  local exit_code
  eval "(( \${#${array_name}[@]} == 0 )) && exit_code=1 || true"
  [[ -n ${exit_code:-} ]] && return "$exit_code"

  local match="$2"
  local e
  shift

  eval "for e in \"\${${array_name}[@]}\"; do [[ \"\$e\" == \"\$match\" ]] && exit_code=0 && return 0; done"
  [[ -n ${exit_code:-} ]] && return "$exit_code" || return 1
}


l.0_4_0_48361424_25787_array_include.s() {
  local array_name=$1
  local exit_code
  eval "(( \${#${array_name}[@]} == 0 )) && echo false && exit_code=1 || true"
  [[ -n ${exit_code:-} ]] && return 0

  local match="$2"
  local e
  shift

  eval "for e in \"\${${array_name}[@]}\"; do [[ \"\$e\" == \"\$match\" ]] && echo true && exit_code=0 && return 0; done || true"

  [[ -z ${exit_code:-} ]] && echo "false" || return 0
}


_l.0_4_0_48361424_25787_ask() {
  local msg=$1
  local default=$2
  local valid_values prompt
  valid_values="$(l.0_4_0_48361424_25787_join values /)"

  if [[ $default == Y ]]; then
    default=yes
    prompt="[$valid_values (default ${default})]"
  elif [[ $default == N ]]; then
    default=no
    prompt="[$valid_values (default ${default})]"
  elif [[ $default == '' ]]; then
    prompt="[$valid_values]"
  else
    echo "Invalid argument 'default'. Valid value is $valid_values. Current=${default}" >&2
    return 3
  fi

  local answer result=''
  [[ -c /dev/tty ]] && echo "$msg" > /dev/tty

  while [[ -z $result ]]; do
    read -rp "$prompt " answer

    if [[ -z $answer ]]; then
      if [[ -z $default ]]; then
        [[ -c /dev/tty ]] && echo ">> Empty answer is not allowed." > /dev/tty
      else
        result="${default^^}"
      fi
    else
      local v
      for v in "${values[@]}"; do
        if l.0_4_0_48361424_25787_start_with "$v" "${answer,,}"; then
          result="${v^^}"
          break
        fi
      done

      if [[ -z $result ]]; then
        [[ -c /dev/tty ]] && echo ">> Invalid answer '$answer'." > /dev/tty
      fi
    fi
  done
  echo "$result"
}

l.0_4_0_48361424_25787_ask() {
  local values=(yes no)
  _l.0_4_0_48361424_25787_ask "$1" "${2:-}"
}


l.0_4_0_48361424_25787_ask_input() {
  local answer prompt
  local default=${2:-}
  if (( $# < 2 )); then
    prompt="${1:-Ask Input:} "
  else
    prompt="${1:-Ask Input:} (Default: $default) "
  fi

  read -rp "$prompt" answer
  printf '%s\n' "${answer:-$default}"
}


l.0_4_0_48361424_25787_ask_with_cancel() {
  local values=(yes no cancel)
  _l.0_4_0_48361424_25787_ask "$1" "${2:-}"
}


l.0_4_0_48361424_25787_basename() {
  local str=${1:-}
  str="${str%/}"
  printf '%s\n' "${str##*/}"
}


l.0_4_0_48361424_25787_basename.p() {
  local str
  IFS='' read -r str

  l.0_4_0_48361424_25787_basename "$str"
}


_l.0_4_0_48361424_25787_run_benchmark() {
  local c=$1
  local repeats=$2

  # Run the given command [repeats] times
  for (( i = 1; i <= "$repeats" ; i++ )); do
    $c > /dev/null 2>&1
  done;
}

l.0_4_0_48361424_25787_benchmark() {
  local c=$1
  local repeats=${2:-10}

  echo "Benchmarking: Run command '$c' [$repeats] times.";
  echo "============="
  type "$c"
  echo "============="

  time _l.0_4_0_48361424_25787_run_benchmark "$c" "$repeats"

  printf '\n--------------------------\n\n'
}


_l.0_4_0_48361424_25787_choose_prompt() {
  printf '  %s\n' 'No. Item'
  local i
  for i in "${!items[@]}"; do
    printf -- '- %-2d  %s\n' $((i + 1)) "${items[$i]}"
  done

  printf 'Please enter the number to choose: \n'
}

l.0_4_0_48361424_25787_choose() {
  local items=("$@")

  local num prompt
  prompt=$(_l.0_4_0_48361424_25787_choose_prompt)
  read -r -p "$prompt" num

  if ! [[ ${num} =~ ^[0-9]+$ ]]; then
    echo "Must enter an integer. Current: $num">&2
    return 3
  fi

  if [[ $num -gt ${#items[@]} ]] || [[ $num -lt 1 ]]; then
   printf '%s\n' "Invalid choose number: $num" >&2
   return 4
  fi

  printf '%s\n' "${items[$((num - 1))]}"
}


l.0_4_0_48361424_25787_compose() {
  local -a last=()
  for f in "$@"; do
    if [[ $(type -t "$f") == function ]]; then
      if (( ${#last[@]} > 0 )); then
        last=( "$($f "${last[@]}")" )
      else
        last=( "$($f)" )
      fi
    else
      last=( "$f" )
    fi
  done
  printf '%s\n' "${last[@]:-}"
}



l.0_4_0_48361424_25787_count_file_lines() {
  wc -l < "$1" | tr -d ' '
}


l.0_4_0_48361424_25787_count_files() {
  local files
  # compgen will return 1 when no matched files
  readarray -t files < <(compgen -f "$1"/ || [[ $? == 1 ]])

  printf '%s\n' "${#files[@]}"
}


l.0_4_0_48361424_25787_count_lines.p() {
  local count=0
  while read -r -d $'\n' _; do
    ((count+=1))
  done
  printf '%s\n' "$count"
}


l.0_4_0_48361424_25787_cur_function_name() {
  # _LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH=2 in built lobash.bash, and _LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH=1 in test.
  printf '%s\n' "${FUNCNAME[$_LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH]}"
}


l.0_4_0_48361424_25787_cursor_col() {
  local COL
  IFS=';' read -rsdR -p $'\E[6n' _ COL
  echo "${COL}"
}



l.0_4_0_48361424_25787_cursor_pos() {
  local CURPOS
  read -rsdR -p $'\E[6n' CURPOS
  CURPOS=${CURPOS#*[} # Strip decoration characters <ESC>[
  echo "${CURPOS}"    # Return position in "row;col" format
}


l.0_4_0_48361424_25787_cursor_row() {
  local ROW
  IFS=';' read -rsdR -p $'\E[6n' ROW _
  # Strip decoration characters <ESC>[
  echo "${ROW#*[}"
}


l.0_4_0_48361424_25787_date() {
  # %(datefmt)T : Causes printf to output the date-time string resulting from using datefmt as a
  # format string for strftime(3). The corresponding argument is an integer representing the number
  # of seconds since the epoch. Two special argument values may be used: -1 represents the
  # current time, and -2 represents the time the shell was invoked. If no argument is specified,
  # conversion behaves as if -1 had been given. This is an exception to the usual printf behavior.
  printf "%($1)T\\n" "-1"
}


l.0_4_0_48361424_25787_detect_os() {
  _lobash.0_4_0_48361424_25787_detect_os
}


l.0_4_0_48361424_25787_dirname() {
  _lobash.0_4_0_48361424_25787_dirname "${1:-}"
}


l.0_4_0_48361424_25787_dirname.p() {
  local str
  IFS='' read -r str
  _lobash.0_4_0_48361424_25787_dirname "$str"
}


l.0_4_0_48361424_25787_echo() {
  printf -- '%b\n' "$*"
}


l.0_4_0_48361424_25787_echo_array() {
  local array_name=$1
  eval "printf '%s\\n' \"\${${array_name}[@]:-}\""
}


l.0_4_0_48361424_25787_echo_screen() {
  # /dev/tty may not exist when run in interactive shell
  (printf -- '%b\n' "$*" >/dev/tty || true) 2>/dev/null
}


l.0_4_0_48361424_25787_end_with() {
  [[ ${1%%"$2"}$2 == "$1" ]]
}


l.0_4_0_48361424_25787_end_with.s() {
  l.0_4_0_48361424_25787_end_with "$@" && echo true || echo false
}


l.0_4_0_48361424_25787_extname() {
  local path=${1:-}
  [[ $path =~ ^\. ]] && echo '' && return
  [[ ! $path =~ \. ]] && echo '' && return
  echo ".${path##*.}"
}


l.0_4_0_48361424_25787_extname.p() {
  local path
  IFS='' read -r path
  l.0_4_0_48361424_25787_extname "$path"
}


l.0_4_0_48361424_25787_first() {
  local array_name=$1
  eval "[[ \${#${array_name}[@]} == 0 ]] && echo '' || printf '%s\\n' \"\${${array_name}[@]:0:1}\""
}


l.0_4_0_48361424_25787_has() {
  local condition="$1"
  local value="$2"

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && return 0;;
    function)
      [[ $(type -t "$value") == function ]] && return 0;;
    alias)
      [[ $(type -t "$value") == alias ]] && return 0;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && return 0;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && return 0;;
    the)
      type -t "$value"
      return $?;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac > /dev/null

  return 1
}


l.0_4_0_48361424_25787_has.s() {
  local condition="$1"
  local value="$2"

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && echo true || echo false;;
    function)
      [[ $(type -t "$value") == function ]] && echo true || echo false;;
    alias)
      [[ $(type -t "$value") == alias ]] && echo true || echo false;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && echo true || echo false;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && echo true || echo false;;
    the)
      type -t "$value" >/dev/null && echo true || echo false;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac
}


l.0_4_0_48361424_25787_has_not() {
  local e=false
  [[ $- =~ e ]] && e=true
  set +e
  l.0_4_0_48361424_25787_has "${@}"
  local result=$?
  [[ $e == true ]] && set -e

  if [[ $result == 0 ]]; then
    return 1
  elif [[ $result == 1 ]]; then
    return 0
  else
    return $result
  fi
}


l.0_4_0_48361424_25787_has_not.s() {
  local r
  r=$(l.0_4_0_48361424_25787_has.s "$@")
  l.0_4_0_48361424_25787_not.s "$r"
}


l.0_4_0_48361424_25787_hex_to_rgb() {
  local hex r g b
  hex="${1/\#}"

  if (( ${#hex} == 6 )); then
    ((r=16#${hex:0:2},g=16#${hex:2:2},b=16#${hex:4:2})) || true
  elif (( ${#hex} == 3 )); then
    ((r=16#${hex:0:1}${hex:0:1},g=16#${hex:1:1}${hex:1:1},b=16#${hex:2:1}${hex:2:1})) || true
  else
    echo 'Argument is not a hex.' >&2
    return 3
  fi

  printf '%s\n%s\n%s\n' "$r" "$g" "$b"
}


l.0_4_0_48361424_25787_hostname() {
  printf '%s\n' "${HOSTNAME:-$(hostname)}"
}


l.0_4_0_48361424_25787_if() {
  local condition
  if [[ $(type -t "$1") == function ]]; then
    condition=$($1)
  else
    condition=$1
  fi

  if [[ $condition == true ]] || [[ $condition == 0 ]]; then
    $2
  elif [[ $condition == false ]] || [[ $condition == 1 ]]; then
    ${3:-}
  else
    echo "Invalid condition: $condition"
    return 3
  fi
}


l.0_4_0_48361424_25787_inc() {
  local var_name=$1
  eval "((${var_name}+=${2:-1})) || true"
}


l.0_4_0_48361424_25787_is_array() {
  [[ -z ${1:-} ]] && return 1

  local str
  str=$(declare -p -- "$1" 2>/dev/null || true)
  [[ -z $str ]] && return 1

  local start="declare -a "
  [[ $start${str##"$start"} == "$str" ]]
}


l.0_4_0_48361424_25787_is_array.s() {
  [[ -z ${1:-} ]] && echo false && return 0

  local str
  str=$(declare -p -- "$1" 2>/dev/null || true)
  [[ -z $str ]] && echo false && return 0

  local start="declare -a "
  [[ $start${str##"$start"} == "$str" ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_bash() {
  _lobash.0_4_0_48361424_25787_is_bash
}


l.0_4_0_48361424_25787_is_bash.s() {
  _lobash.0_4_0_48361424_25787_is_bash && echo true || echo false
}


l.0_4_0_48361424_25787_is_dir() {
  [[ -d ${1:-} ]]
}


l.0_4_0_48361424_25787_is_dir.s() {
  [[ -d ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_executable() {
  [[ -x ${1:-} ]]
}


l.0_4_0_48361424_25787_is_executable.s() {
  [[ -x ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_executable_file() {
  [[ -z ${1:-} ]] && return 1

  if l.0_4_0_48361424_25787_is_dir "$1"; then
    # directory is executable
    # https://superuser.com/a/168583
    return 1
  else
    [[ -x $1 ]]
  fi
}


l.0_4_0_48361424_25787_is_executable_file.s() {
  l.0_4_0_48361424_25787_is_executable_file "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_falsy() {
  [[ -z ${1:-} ]] && return 1

  if l.0_4_0_48361424_25787_is_integer "$1"; then
    [[ $1 != 0 ]]
  else
    [[ $1 == false ]]
  fi
}


l.0_4_0_48361424_25787_is_falsy.s() {
  l.0_4_0_48361424_25787_is_falsy "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_file() {
  [[ -f ${1:-} ]]
}


l.0_4_0_48361424_25787_is_file.s() {
  [[ -f ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_float() {
  [[ ${1:-} =~ ^[-+]?[0-9]+([.][0-9]+)?$ ]]
}


l.0_4_0_48361424_25787_is_float.s() {
  l.0_4_0_48361424_25787_is_float "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_integer() {
  [[ ${1:-} =~ ^[-+]?[0-9]+$ ]]
}


l.0_4_0_48361424_25787_is_integer.s() {
  l.0_4_0_48361424_25787_is_integer "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_link() {
  [[ -L ${1:-} ]]
}


l.0_4_0_48361424_25787_is_link.s() {
  [[ -L ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_number() {
  [[ ${1:-} =~ ^[-+]?[0-9]+(.[0-9]+)?$ ]]
}


l.0_4_0_48361424_25787_is_number.s() {
  l.0_4_0_48361424_25787_is_number "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_readable() {
  [[ -r ${1:-} ]]
}


l.0_4_0_48361424_25787_is_readable.s() {
  [[ -r ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_is_truthy() {
  [[ ${1:-} == true ]] || [[ ${1:-} == 0 ]]
}


l.0_4_0_48361424_25787_is_truthy.s() {
  l.0_4_0_48361424_25787_is_truthy "${1:-}" && echo true || echo false
}


l.0_4_0_48361424_25787_is_ubuntu() {
  if [[ -e /etc/os-release ]]; then
    local dist=$(awk -F= '/^NAME/{print $2}' /etc/os-release)
    if [[ $dist == '"Ubuntu"' ]]; then
      return 0
    fi
  fi

  return 1
}


l.0_4_0_48361424_25787_is_writable() {
  [[ -w ${1:-} ]]
}


l.0_4_0_48361424_25787_is_writable.s() {
  [[ -w ${1:-} ]] && echo true || echo false
}


l.0_4_0_48361424_25787_join() {
  local array_name=$1
  local _IFS=$IFS
  if [[ $# == 1 ]]; then
    IFS=,
  else
    IFS=${2}
  fi
  eval "printf '%s\\n' \"\${${array_name}[*]:-}\""
  IFS=$_IFS
}


l.0_4_0_48361424_25787_keys() {
  local name=$1
  eval "for key in \"\${!${name}[@]}\" ; do printf '%s\\n' \"\$key\"; done"
}


l.0_4_0_48361424_25787_last() {
  local array_name=$1
  eval "[[ \${#${array_name}[@]} == 0 ]] && echo '' || printf '%s\\n' \"\${${array_name}[@]: -1:1}\""
}



l.0_4_0_48361424_25787_lower_case() {
  local str=${1:-}
  printf '%s\n' "${str,,}"
}


l.0_4_0_48361424_25787_lower_case.p() {
  local str
  IFS='' read -r str
  l.0_4_0_48361424_25787_lower_case "$str"
}


l.0_4_0_48361424_25787_lower_first() {
  local str=${1:-}
  printf '%s\n' "${str,}"
}


l.0_4_0_48361424_25787_lower_first.p() {
  local str
  IFS='' read -r str
  l.0_4_0_48361424_25787_lower_first "$str"
}


l.0_4_0_48361424_25787_match() {
  [[ ${3:-} == 0 ]] && echo "index cannot be 0" >&2 && return 3

  if [[ $1 =~ $2 ]]; then
    if (( ${#BASH_REMATCH[@]} > 1 )); then
      printf '%s\n' "${BASH_REMATCH[${3:-1}]}"
    else
      echo ''
    fi
  else
    echo ''
  fi
}


l.0_4_0_48361424_25787_match_list() {
  (( $# != 3 )) && echo "wrong parameters" >&2 && return 3

  local output_array_name=$3

  if [[ $1 =~ $2 ]]; then
    local len=${#BASH_REMATCH[@]}
    local i
    if (( len > 1 )); then
      for (( i = 1; i < len; i++ )); do
        eval "${output_array_name}+=( \"\${BASH_REMATCH[$i]}\" )"
      done
    fi
  fi
}


l.0_4_0_48361424_25787_normalize() {
  local path=${1:-}

  if [[ -z ${path} ]]; then
    echo '.'
    return 0
  fi

  if [[ ${path} == '.' ]]; then
    echo '.'
    return 0
  fi

  local -a words
  l.0_4_0_48361424_25787_split "$path" words '/'
  local -a list=()
  local -a pre_list=()
  local n=0
  local i

  if [[ ${path:0:1} == '/' ]]; then
    pre_list+=(/)
  else
    for i in "${words[@]}"; do
      if [[ $i =~ ^'.' ]]; then
        ((n+=1))
        pre_list+=("$i")
      else
        break
      fi
    done
  fi

  for (( ; n < ${#words[@]}; n++ )); do
    i=${words[$n]}
    if [[ $i == '' ]] || [[ $i == '.' ]]; then
      true
    elif [[ $i == '..' ]]; then
      local k=$(( ${#list[@]} - 1)) || true
      [[ $k > -1 ]] && unset list["$k"]
    else
      list+=("$i")
    fi
  done

  printf '%s%s\n' "$(l.0_4_0_48361424_25787_join pre_list '/')" "$(l.0_4_0_48361424_25787_join list '/')"
}


l.0_4_0_48361424_25787_normalize.p() {
  local path
  IFS='' read -r path
  l.0_4_0_48361424_25787_normalize "$path"
}


l.0_4_0_48361424_25787_not.s() {
  local condition="${1:-}"

  if [[ $condition == true ]]; then
    echo false;
  elif [[ $condition == false ]]; then
    echo true
  else
    echo "Invalid condition! It must be one of 'true' and 'false'. Current value=$condition" >&2
    return 3
  fi
}


l.0_4_0_48361424_25787_not.s.p() {
  local condition
  read -r condition
  l.0_4_0_48361424_25787_not.s "$condition"
}


_l.0_4_0_48361424_25787_perl_now() {
  perl -MTime::HiRes=time -e 'printf "%d\n", time * 1000'
}

l.0_4_0_48361424_25787_now() {
  local timestamp
  if [[ $_LOBASH_0_4_0_48361424_25787_OS == 'MacOS' ]]; then
    # date '+%N' not supported in MacOS.
    _l.0_4_0_48361424_25787_perl_now
  else
    # Some Linux systems may not install the Perl module "Time::HiRes".
    # So use date '+%3N' to get milliseconds.
    timestamp=$(date '+%s%3N')

    if [[ ${#timestamp} == 10 ]]; then
      # But the date '+%N' is GNU date feature which not supported in Alpine/Busybox systems.
      _l.0_4_0_48361424_25787_perl_now
    else
      printf '%s\n' "$timestamp"
    fi
  fi
}


l.0_4_0_48361424_25787_now_s() {
  l.0_4_0_48361424_25787_date '%s'
}


_l.0_4_0_48361424_25787_parse_single_hyphen_options() {
  local param=${1#-}

  # Possible Formats:
  # -a 3 or -abc 3
  # -a or -a3 or -abc3
  # -a=3 or -abc=3
  # -a= or -abc=

  local -a matches=()
  local k letters
  l.0_4_0_48361424_25787_match_list "$param" '^(.+)=(.*)$' matches
  if (( ${#matches[@]} == 2 )); then
    # -a=3 or -abc=3
    # -a= or -abc=
    letters=${matches[0]}
    $add_opt "${letters: -1:1}" "${matches[1]}"

    letters=${letters:0:$(( ${#letters} - 1 ))}
    for (( k = 0; k < ${#letters} ; k++ )); do
      $add_opt "${letters:$k:1}" true
    done
    return
  fi

  if (( $# == 2 )); then
    # -a 3 or -abc 3
    $add_opt "${param: -1:1}" "$2"
    (( i+=1 ))

    letters=${param:0:$(( ${#param} - 1 ))}
    for (( k = 0; k < ${#letters}; k++ )); do
      $add_opt "${letters:$k:1}" true
    done
    return
  else
    # -a or -a3 or -abc3
    for (( k = 0; k < ${#param}; k++ )); do
      $add_opt "${param:$k:1}" true
    done
    return
  fi

  echo "Unknown option: -$param" >&2
  return 4
}

_l.0_4_0_48361424_25787_parse_double_hyphen_options() {
  local param=${1#--}

  local -a matches=()
  l.0_4_0_48361424_25787_match_list "$param" '^(.+)=(.*)' matches

  if (( ${#matches[@]} == 2 )); then
    $add_opt "${matches[0]}" "${matches[1]}"
  else
    local key
    key=$(l.0_4_0_48361424_25787_match "$param" '^no-(.+)')
    if [[ -n $key ]]; then
      $add_opt "${key}" false
    else
      key=$param
      if (( $# == 2 )); then
        $add_opt "${key}" "$2"
      else
        $add_opt "${key}" true
      fi
    fi
  fi
}

_l.0_4_0_48361424_25787_parse_params_add_none() {
  return 0
}

_l.0_4_0_48361424_25787_parse_params_add_opt() {
  eval "$opts_name[\$1]=\"\$2\""
}

_l.0_4_0_48361424_25787_parse_params_add_arg() {
  eval "$args_name+=(\"\$1\")"
}

l.0_4_0_48361424_25787_parse_params() {
  if (( $# < 2 )); then
    echo "parse_params: programming error. Parameters cannot less than 2." >&2
    return 3
  fi

  local add_opt add_arg
  if [[ $1 != _ ]]; then
    local opts_name=$1
    add_opt=_l.0_4_0_48361424_25787_parse_params_add_opt
  else
    add_opt=_l.0_4_0_48361424_25787_parse_params_add_none
  fi

  if [[ $2 != _ ]]; then
    local args_name=$2
    add_arg=_l.0_4_0_48361424_25787_parse_params_add_arg
  else
    add_arg=_l.0_4_0_48361424_25787_parse_params_add_none
  fi

  local param_size=$#
  local param
  local rest_is_args=false
  for (( i = 3; i <= param_size; i++ )); do
    param=${!i}

    if l.0_4_0_48361424_25787_start_with "$param" '-'; then
      local j=$(( i+1 ))
      local f

      if [[ $param == '--' ]]; then
        rest_is_args=true
        (( i+=1 ))
        break;
      fi

      if l.0_4_0_48361424_25787_start_with "$param" '--'; then
        f=_l.0_4_0_48361424_25787_parse_double_hyphen_options
      else
        f=_l.0_4_0_48361424_25787_parse_single_hyphen_options
      fi

      if (( j > param_size )) ; then
        $f "$param"
      else
        local next=${!j}
        if l.0_4_0_48361424_25787_start_with "$next" '-' ; then
          $f "$param"
        else
          $f "$param" "$next"
        fi
      fi
    else
      $add_arg "$param"
    fi
  done

  if [[ $rest_is_args == true ]]; then
    for (( ; i <= param_size; i++ )); do
      $add_arg "${!i}"
    done
  fi
}


l.0_4_0_48361424_25787_pwd() {
  printf '%s\n' "$PWD"
}


l.0_4_0_48361424_25787_random() {
  local length=${1:-10}
  local pattern=${2:-a-zA-Z0-9@#*=[]}
  printf '%s\n' "$(LC_ALL=C tr -dc "$pattern" < /dev/urandom | head -c "$length" || true)"
}


l.0_4_0_48361424_25787_repeat() {
  local -i n=$1
  (( n == 0 )) && return
  (( n < 0 )) && return

  shift
  for n in $(seq "$n"); do
    "$@"
  done
}


l.0_4_0_48361424_25787_rgb_to_hex() {
  if (( $# != 3 )); then
    echo 'The arguments size not equal 3' >&2
    return 3
  fi

  if ! l.0_4_0_48361424_25787_is_number "$1"; then
    echo 'The first argument is not a number' >&2
    return 4
  fi

  if ! l.0_4_0_48361424_25787_is_number "$2"; then
    echo 'The second argument is not a number' >&2
    return 5
  fi

  if ! l.0_4_0_48361424_25787_is_number "$3"; then
    echo 'The third argument is not a number' >&2
    return 6
  fi

  printf '#%02x%02x%02x\n' "$1" "$2" "$3"
}



if [[ $OSTYPE =~ darwin ]]; then
  _L_0_4_0_48361424_25787_SLEEP_TEMP=$(mktemp -u)
  # Create a FIFO special file
  mkfifo -m 700 "$_L_0_4_0_48361424_25787_SLEEP_TEMP"
fi

l.0_4_0_48361424_25787_sleep() {
  # Reset IFS in case it’s set to something weird.
  local IFS
  local _sleep_fd

  if [[ $OSTYPE =~ darwin ]]; then
    # MacOS will show shows "/dev/fd/62: Permission denied" on `exec {_sleep_fd}<> <(true)`. So we make a workaround.

    # local _L_0_4_0_48361424_25787_SLEEP_TEMP
    # Get available temp file path
    # _L_0_4_0_48361424_25787_SLEEP_TEMP=$(mktemp -u)
    # # Create a FIFO special file
    # mkfifo -m 700 "$_L_0_4_0_48361424_25787_SLEEP_TEMP"
    exec {_sleep_fd}<>"$_L_0_4_0_48361424_25787_SLEEP_TEMP"
    # rm -f "$_L_0_4_0_48361424_25787_SLEEP_TEMP"
  else
    exec {_sleep_fd}<> <(true)
  fi

  # Wait for timeout
  read -rst "${1:-1}" -u "$_sleep_fd" || true
  # Close fd
  exec {_sleep_fd}<&-
}


l.0_4_0_48361424_25787_sort() {
  local array_name=$1
  shift
  eval "printf '%s\\n' \"\${${array_name}[@]:-}\" | sort \"\$@\""
}


_l.0_4_0_48361424_25787_split() {
  local -i i

  local dLen=${#delimiter}
  local sLen=${#string}

  if [[ $delimiter == '' ]]; then
    for (( i=0; i < sLen; i++ )); do
      printf '%s\n' "${string:$i:1}"
    done
    return 0
  fi

  local -a indexes=()
  local -i a=0 b=0 d

  while (( a < "$sLen" )); do
    for (( b=a+1; b <= sLen; b++ )); do
      d=$(( b - a )) || true
      if (( d > dLen )); then
        break;
      fi

      if [[ "${string:$a:$d}" == "$delimiter" ]]; then
        indexes+=("$a")
      fi
    done
    (( a++ )) || true
  done

  a=0
  if (( ${#indexes[@]} > 0 )); then
    for i in "${indexes[@]}"; do
      printf '%s\n' "${string:$a:$(( i - a ))}"
      a=$((i + dLen));
    done
  fi

  if (( a < sLen )); then
    printf '%s\n' "${string:$a}"
  elif (( a == sLen )); then
    printf '\n'
  fi
}

l.0_4_0_48361424_25787_split() {
  local string=$1
  local output=$2
  local delimiter
  if [[ $# == 2 ]]; then
    delimiter=' '
  else
    delimiter="${3}"
  fi

  IFS=$'\n' readarray -t "$output" < <(_l.0_4_0_48361424_25787_split)
}


l.0_4_0_48361424_25787_start_with() {
  [[ $2${1##"$2"} == "$1" ]]
}


l.0_4_0_48361424_25787_start_with.s() {
  l.0_4_0_48361424_25787_start_with "$@" && echo true || echo false
}



l.0_4_0_48361424_25787_str_include() {
  [[ "${1:-}" =~ "${2:-}" ]]
}



l.0_4_0_48361424_25787_str_include.s() {
  l.0_4_0_48361424_25787_str_include "$@" && echo true || echo false;
}


l.0_4_0_48361424_25787_str_len() {
  [[ -z ${1:-} ]] && echo 0 && return

  local old_lang old_lc_all bytlen
  [[ -n ${LC_ALL:-} ]] && old_lc_all=$LC_ALL
  [[ -n ${LANG:-} ]] && old_lang=$LANG

  LANG=C LC_ALL=C
  bytlen=${#1}
  printf -- '%s\n' "$bytlen"

  [[ -n ${old_lang:-} ]] && LANG=$old_lang
  if [[ -n ${old_lc_all:-} ]]; then
    LC_ALL=$old_lc_all
  fi
}


l.0_4_0_48361424_25787_str_size() {
  [[ -z ${1:-} ]] && echo 0 && return

  # It not work with double-width characters when environment LANG is not UTF-8.
  local OLD_LANG
  [[ -n ${LANG:-} ]] && OLD_LANG=$LANG

  LANG=C.UTF-8
  printf '%s\n' "${#1}"

  if [[ -n ${OLD_LANG:-} ]]; then
    LANG=$OLD_LANG
  fi
}


l.0_4_0_48361424_25787_sub() {
  local var_name=$1
  eval "((${var_name}-=${2:-1})) || true"
}


l.0_4_0_48361424_25787_trace_count() {
  local label=${1:-trace}
  local key=_LOBASH_0_4_0_48361424_25787_trace_count_$label

  if [[ -z ${!key:-} ]]; then
    read -r "$key" <<< 0
  fi

  read -r "$key" <<< $(( ${!key} + 1 ))

  printf '[%s] count: %s\n' "$label" "${!key}"
}


l.0_4_0_48361424_25787_trace_end() {
  set +o xtrace
  PS4=${_L_0_4_0_48361424_25787_TRACE_OLD_PS4:-$PS4}
}


l.0_4_0_48361424_25787_trace_stack() {
  printf '%s\n%s\n' \
    "Trace Function Stack:${1:+ $1}" \
    "  # Function (File:Line)"

  # _LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH=2 in built lobash.bash, and _LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH=1 in test or develop.
  for i in $(seq "$_LOBASH_0_4_0_48361424_25787_PUBLIC_DEPTH" $(( ${#FUNCNAME[@]} -1 ))); do
    printf -- '  - %s (%s:%s)\n' "${FUNCNAME[$i]}" "${BASH_SOURCE[$i]:-(shell)}" "${BASH_LINENO[$i]}"
  done
}


l.0_4_0_48361424_25787_trace_start() {
  read -r _L_0_4_0_48361424_25787_TRACE_OLD_PS4 <<< "$PS4"
  local label=${2:-}
  [[ -n "$label" ]] && label="[$label]"

  case ${1:-2} in
    1 )
      PS4='+'${label}'[${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    2 )
      PS4='+'${label}'[$(basename ${BASH_SOURCE[0]}):${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    3 )
      PS4='+'${label}'[${BASH_SOURCE[0]}:${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    * )
      echo "Invalid PS4_LEVEL: $1" >&2
      return 3
      ;;
  esac

  set -o xtrace
}


l.0_4_0_48361424_25787_trace_time() {
  local label=${1:-debug}
  local key=_LOBASH_0_4_0_48361424_25787_TRACE_TIME_$label
  local last_time=${!key:-}
  local current
  current="$(l.0_4_0_48361424_25787_now)"

  printf '[%s] Current Timestamp: %s\n' "$label" "$current"

  if [[ -n $last_time ]]; then
    printf '[%s] Last Timestamp: %s\n[%s] Elapsed: %s\n' "$label" "$last_time" "$label" $(( $(l.0_4_0_48361424_25787_now) - last_time ))
    read -r "$key" <<< "$current"
  else
    read -r "$key" <<< "$current"
  fi
}


_l.0_4_0_48361424_25787_trap_error() {
  echo "Error occurred. Error Stacks:" >&2

  local frame=0 LINE FUNC FILE
  while read -r LINE FUNC FILE < <(caller "$frame"); do
    printf -- '  - %s (%s:%s)\n' "${FUNC}" "${FILE}" "${LINE}"
    frame=$(( frame + 1 ))
  done
}

l.0_4_0_48361424_25787_trap_error() {
  local trap_func=${1:-_l.0_4_0_48361424_25787_trap_error}
  # shellcheck disable=SC2064
  trap "$trap_func" ERR
}


l.0_4_0_48361424_25787_trim() {
  local str=${1:-}
  str=$(l.0_4_0_48361424_25787_trim_start "$str")
  l.0_4_0_48361424_25787_trim_end "$str"
}


l.0_4_0_48361424_25787_trim.p() {
  local str
  read -r str
  l.0_4_0_48361424_25787_trim "$str"
}


_L_0_4_0_48361424_25787_TRIM_COLOR_ECS=$'\e'
_L_0_4_0_48361424_25787_TRIM_COLOR_ECS2=$'\u001b'
if [[ "$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS" == "$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS2" ]]; then
  if [[ $_LOBASH_0_4_0_48361424_25787_OS == Linux ]]; then
    _L_0_4_0_48361424_25787_TRIM_COLOR_REGEX=$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS
  elif [[ $_LOBASH_0_4_0_48361424_25787_OS == MacOS ]] || [[ $_LOBASH_0_4_0_48361424_25787_OS == BSD ]]; then
    _L_0_4_0_48361424_25787_TRIM_COLOR_REGEX="\\$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS"
  fi
else
  if [[ $_LOBASH_0_4_0_48361424_25787_OS == Linux ]]; then
    _L_0_4_0_48361424_25787_TRIM_COLOR_REGEX="($_L_0_4_0_48361424_25787_TRIM_COLOR_ECS|\\$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS2)"
  elif [[ $_LOBASH_0_4_0_48361424_25787_OS == MacOS ]] || [[ $_LOBASH_0_4_0_48361424_25787_OS == BSD ]]; then
    _L_0_4_0_48361424_25787_TRIM_COLOR_REGEX="(\\$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS|\\$_L_0_4_0_48361424_25787_TRIM_COLOR_ECS2)"
  fi
fi

l.0_4_0_48361424_25787_trim_color() {
  ( (( $# == 0 )) || [[ -z ${1:-} ]]) && echo '' && return
  sed -E "s,${_L_0_4_0_48361424_25787_TRIM_COLOR_REGEX}[[0-9]*(;[0-9]+)*m,,g" <<< "$1"
}


l.0_4_0_48361424_25787_trim_color.p() {
  local str
  read -r str
  l.0_4_0_48361424_25787_trim_color "$str"
}


l.0_4_0_48361424_25787_trim_end() {
  local str=${1:-}
  if (( $# < 2 )); then
    # https://stackoverflow.com/a/3352015
    printf '%s\n' "${str%"${str##*[![:space:]]}"}"
  else
    printf '%s\n' "${str%%$2}"
  fi
}


l.0_4_0_48361424_25787_trim_end.p() {
  local str
  IFS='' read -r str

  if (( $# == 0 )); then
    l.0_4_0_48361424_25787_trim_end "$str"
  else
    l.0_4_0_48361424_25787_trim_end "$str" "${@}"
  fi
}


l.0_4_0_48361424_25787_trim_start() {
  local str=${1:-}
  if (( $# < 2 )); then
    # https://stackoverflow.com/a/3352015
    printf '%s\n' "${str#"${str%%[![:space:]]*}"}"
  else
    printf '%s\n' "${str##$2}"
  fi
}


l.0_4_0_48361424_25787_trim_start.p() {
  local str
  IFS='' read -r str

  if (( $# == 0 )); then
    l.0_4_0_48361424_25787_trim_start "$str"
  else
    l.0_4_0_48361424_25787_trim_start "$str" "${@}"
  fi
}


_l.0_4_0_48361424_25787_union_array() {
  if [[ -z ${l_union_array_map[$l_union_array_item]:-} ]]; then
    l_union_array_arr+=("$l_union_array_item")
    l_union_array_map["$l_union_array_item"]=1
  fi
}

l.0_4_0_48361424_25787_union_array() {
  local -A l_union_array_map
  local l_union_array_item
  local -a l_union_array_arr

  local array_arr1=$1
  eval "for l_union_array_item in \"\${${array_arr1}[@]}\"; do _l.0_4_0_48361424_25787_union_array; done || true"

  if (( $# > 1 )); then
    local array_arr2=$2
    eval "for l_union_array_item in \"\${${array_arr2}[@]}\"; do _l.0_4_0_48361424_25787_union_array; done || true"
  fi

  l.0_4_0_48361424_25787_echo_array l_union_array_arr
}



l.0_4_0_48361424_25787_upper_case() {
  local str=${1:-}
  printf '%s\n' "${str^^}"
}


l.0_4_0_48361424_25787_upper_case.p() {
  local str
  IFS='' read -r str
  l.0_4_0_48361424_25787_upper_case "$str"
}


l.0_4_0_48361424_25787_upper_first() {
  local str=${1:-}
  printf '%s\n' "${str^}"
}


l.0_4_0_48361424_25787_upper_first.p() {
  local str
  IFS='' read -r str
  l.0_4_0_48361424_25787_upper_first "$str"
}


l.0_4_0_48361424_25787_with_ifs() {
  _lobash.0_4_0_48361424_25787_with_IFS "$@"
}


l.0_4_0_48361424_25787_xdg_config_home() {
  printf '%s\n' "${XDG_CONFIG_HOME:-${HOME}/.config}"
}

######################## Public Methods ########################
dotfiles_l.array_include() { l.0_4_0_48361424_25787_array_include "$@"; }
dotfiles_l.array_include.s() { l.0_4_0_48361424_25787_array_include.s "$@"; }
dotfiles_l.ask() { l.0_4_0_48361424_25787_ask "$@"; }
dotfiles_l.ask_input() { l.0_4_0_48361424_25787_ask_input "$@"; }
dotfiles_l.ask_with_cancel() { l.0_4_0_48361424_25787_ask_with_cancel "$@"; }
dotfiles_l.basename() { l.0_4_0_48361424_25787_basename "$@"; }
dotfiles_l.basename.p() { l.0_4_0_48361424_25787_basename.p "$@"; }
dotfiles_l.benchmark() { l.0_4_0_48361424_25787_benchmark "$@"; }
dotfiles_l.choose() { l.0_4_0_48361424_25787_choose "$@"; }
dotfiles_l.compose() { l.0_4_0_48361424_25787_compose "$@"; }
dotfiles_l.count_file_lines() { l.0_4_0_48361424_25787_count_file_lines "$@"; }
dotfiles_l.count_files() { l.0_4_0_48361424_25787_count_files "$@"; }
dotfiles_l.count_lines.p() { l.0_4_0_48361424_25787_count_lines.p "$@"; }
dotfiles_l.cur_function_name() { l.0_4_0_48361424_25787_cur_function_name "$@"; }
dotfiles_l.cursor_col() { l.0_4_0_48361424_25787_cursor_col "$@"; }
dotfiles_l.cursor_pos() { l.0_4_0_48361424_25787_cursor_pos "$@"; }
dotfiles_l.cursor_row() { l.0_4_0_48361424_25787_cursor_row "$@"; }
dotfiles_l.date() { l.0_4_0_48361424_25787_date "$@"; }
dotfiles_l.detect_os() { l.0_4_0_48361424_25787_detect_os "$@"; }
dotfiles_l.dirname() { l.0_4_0_48361424_25787_dirname "$@"; }
dotfiles_l.dirname.p() { l.0_4_0_48361424_25787_dirname.p "$@"; }
dotfiles_l.echo() { l.0_4_0_48361424_25787_echo "$@"; }
dotfiles_l.echo_array() { l.0_4_0_48361424_25787_echo_array "$@"; }
dotfiles_l.echo_screen() { l.0_4_0_48361424_25787_echo_screen "$@"; }
dotfiles_l.end_with() { l.0_4_0_48361424_25787_end_with "$@"; }
dotfiles_l.end_with.s() { l.0_4_0_48361424_25787_end_with.s "$@"; }
dotfiles_l.extname() { l.0_4_0_48361424_25787_extname "$@"; }
dotfiles_l.extname.p() { l.0_4_0_48361424_25787_extname.p "$@"; }
dotfiles_l.first() { l.0_4_0_48361424_25787_first "$@"; }
dotfiles_l.has() { l.0_4_0_48361424_25787_has "$@"; }
dotfiles_l.has.s() { l.0_4_0_48361424_25787_has.s "$@"; }
dotfiles_l.has_not() { l.0_4_0_48361424_25787_has_not "$@"; }
dotfiles_l.has_not.s() { l.0_4_0_48361424_25787_has_not.s "$@"; }
dotfiles_l.hex_to_rgb() { l.0_4_0_48361424_25787_hex_to_rgb "$@"; }
dotfiles_l.hostname() { l.0_4_0_48361424_25787_hostname "$@"; }
dotfiles_l.if() { l.0_4_0_48361424_25787_if "$@"; }
dotfiles_l.inc() { l.0_4_0_48361424_25787_inc "$@"; }
dotfiles_l.is_array() { l.0_4_0_48361424_25787_is_array "$@"; }
dotfiles_l.is_array.s() { l.0_4_0_48361424_25787_is_array.s "$@"; }
dotfiles_l.is_bash() { l.0_4_0_48361424_25787_is_bash "$@"; }
dotfiles_l.is_bash.s() { l.0_4_0_48361424_25787_is_bash.s "$@"; }
dotfiles_l.is_dir() { l.0_4_0_48361424_25787_is_dir "$@"; }
dotfiles_l.is_dir.s() { l.0_4_0_48361424_25787_is_dir.s "$@"; }
dotfiles_l.is_executable() { l.0_4_0_48361424_25787_is_executable "$@"; }
dotfiles_l.is_executable.s() { l.0_4_0_48361424_25787_is_executable.s "$@"; }
dotfiles_l.is_executable_file() { l.0_4_0_48361424_25787_is_executable_file "$@"; }
dotfiles_l.is_executable_file.s() { l.0_4_0_48361424_25787_is_executable_file.s "$@"; }
dotfiles_l.is_falsy() { l.0_4_0_48361424_25787_is_falsy "$@"; }
dotfiles_l.is_falsy.s() { l.0_4_0_48361424_25787_is_falsy.s "$@"; }
dotfiles_l.is_file() { l.0_4_0_48361424_25787_is_file "$@"; }
dotfiles_l.is_file.s() { l.0_4_0_48361424_25787_is_file.s "$@"; }
dotfiles_l.is_float() { l.0_4_0_48361424_25787_is_float "$@"; }
dotfiles_l.is_float.s() { l.0_4_0_48361424_25787_is_float.s "$@"; }
dotfiles_l.is_integer() { l.0_4_0_48361424_25787_is_integer "$@"; }
dotfiles_l.is_integer.s() { l.0_4_0_48361424_25787_is_integer.s "$@"; }
dotfiles_l.is_link() { l.0_4_0_48361424_25787_is_link "$@"; }
dotfiles_l.is_link.s() { l.0_4_0_48361424_25787_is_link.s "$@"; }
dotfiles_l.is_number() { l.0_4_0_48361424_25787_is_number "$@"; }
dotfiles_l.is_number.s() { l.0_4_0_48361424_25787_is_number.s "$@"; }
dotfiles_l.is_readable() { l.0_4_0_48361424_25787_is_readable "$@"; }
dotfiles_l.is_readable.s() { l.0_4_0_48361424_25787_is_readable.s "$@"; }
dotfiles_l.is_truthy() { l.0_4_0_48361424_25787_is_truthy "$@"; }
dotfiles_l.is_truthy.s() { l.0_4_0_48361424_25787_is_truthy.s "$@"; }
dotfiles_l.is_ubuntu() { l.0_4_0_48361424_25787_is_ubuntu "$@"; }
dotfiles_l.is_writable() { l.0_4_0_48361424_25787_is_writable "$@"; }
dotfiles_l.is_writable.s() { l.0_4_0_48361424_25787_is_writable.s "$@"; }
dotfiles_l.join() { l.0_4_0_48361424_25787_join "$@"; }
dotfiles_l.keys() { l.0_4_0_48361424_25787_keys "$@"; }
dotfiles_l.last() { l.0_4_0_48361424_25787_last "$@"; }
dotfiles_l.lower_case() { l.0_4_0_48361424_25787_lower_case "$@"; }
dotfiles_l.lower_case.p() { l.0_4_0_48361424_25787_lower_case.p "$@"; }
dotfiles_l.lower_first() { l.0_4_0_48361424_25787_lower_first "$@"; }
dotfiles_l.lower_first.p() { l.0_4_0_48361424_25787_lower_first.p "$@"; }
dotfiles_l.match() { l.0_4_0_48361424_25787_match "$@"; }
dotfiles_l.match_list() { l.0_4_0_48361424_25787_match_list "$@"; }
dotfiles_l.normalize() { l.0_4_0_48361424_25787_normalize "$@"; }
dotfiles_l.normalize.p() { l.0_4_0_48361424_25787_normalize.p "$@"; }
dotfiles_l.not.s() { l.0_4_0_48361424_25787_not.s "$@"; }
dotfiles_l.not.s.p() { l.0_4_0_48361424_25787_not.s.p "$@"; }
dotfiles_l.now() { l.0_4_0_48361424_25787_now "$@"; }
dotfiles_l.now_s() { l.0_4_0_48361424_25787_now_s "$@"; }
dotfiles_l.parse_params() { l.0_4_0_48361424_25787_parse_params "$@"; }
dotfiles_l.pwd() { l.0_4_0_48361424_25787_pwd "$@"; }
dotfiles_l.random() { l.0_4_0_48361424_25787_random "$@"; }
dotfiles_l.repeat() { l.0_4_0_48361424_25787_repeat "$@"; }
dotfiles_l.rgb_to_hex() { l.0_4_0_48361424_25787_rgb_to_hex "$@"; }
dotfiles_l.sleep() { l.0_4_0_48361424_25787_sleep "$@"; }
dotfiles_l.sort() { l.0_4_0_48361424_25787_sort "$@"; }
dotfiles_l.split() { l.0_4_0_48361424_25787_split "$@"; }
dotfiles_l.start_with() { l.0_4_0_48361424_25787_start_with "$@"; }
dotfiles_l.start_with.s() { l.0_4_0_48361424_25787_start_with.s "$@"; }
dotfiles_l.str_include() { l.0_4_0_48361424_25787_str_include "$@"; }
dotfiles_l.str_include.s() { l.0_4_0_48361424_25787_str_include.s "$@"; }
dotfiles_l.str_len() { l.0_4_0_48361424_25787_str_len "$@"; }
dotfiles_l.str_size() { l.0_4_0_48361424_25787_str_size "$@"; }
dotfiles_l.sub() { l.0_4_0_48361424_25787_sub "$@"; }
dotfiles_l.trace_count() { l.0_4_0_48361424_25787_trace_count "$@"; }
dotfiles_l.trace_end() { l.0_4_0_48361424_25787_trace_end "$@"; }
dotfiles_l.trace_stack() { l.0_4_0_48361424_25787_trace_stack "$@"; }
dotfiles_l.trace_start() { l.0_4_0_48361424_25787_trace_start "$@"; }
dotfiles_l.trace_time() { l.0_4_0_48361424_25787_trace_time "$@"; }
dotfiles_l.trap_error() { l.0_4_0_48361424_25787_trap_error "$@"; }
dotfiles_l.trim() { l.0_4_0_48361424_25787_trim "$@"; }
dotfiles_l.trim.p() { l.0_4_0_48361424_25787_trim.p "$@"; }
dotfiles_l.trim_color() { l.0_4_0_48361424_25787_trim_color "$@"; }
dotfiles_l.trim_color.p() { l.0_4_0_48361424_25787_trim_color.p "$@"; }
dotfiles_l.trim_end() { l.0_4_0_48361424_25787_trim_end "$@"; }
dotfiles_l.trim_end.p() { l.0_4_0_48361424_25787_trim_end.p "$@"; }
dotfiles_l.trim_start() { l.0_4_0_48361424_25787_trim_start "$@"; }
dotfiles_l.trim_start.p() { l.0_4_0_48361424_25787_trim_start.p "$@"; }
dotfiles_l.union_array() { l.0_4_0_48361424_25787_union_array "$@"; }
dotfiles_l.upper_case() { l.0_4_0_48361424_25787_upper_case "$@"; }
dotfiles_l.upper_case.p() { l.0_4_0_48361424_25787_upper_case.p "$@"; }
dotfiles_l.upper_first() { l.0_4_0_48361424_25787_upper_first "$@"; }
dotfiles_l.upper_first.p() { l.0_4_0_48361424_25787_upper_first.p "$@"; }
dotfiles_l.with_ifs() { l.0_4_0_48361424_25787_with_ifs "$@"; }
dotfiles_l.xdg_config_home() { l.0_4_0_48361424_25787_xdg_config_home "$@"; }
