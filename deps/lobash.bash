# This file is generated by https://github.com/adoyle-h/lobash
# Author: ADoyle <adoyle.h@gmail.com>
# License: Apache License Version 2.0
# Version: 0.1.0
# Prefix: l.

######################## Lobash Internals ########################

_lobash.0_1_0_3385_13492_get_shell_type() {
  if [[ -n ${BASH_VERSION:-} ]]; then
    echo bash
  elif [[ -n ${ZSH_VERSION:-} ]]; then
    echo zsh
  else
    echo 'Lobash only work in Bash and Zsh.' >&2
    return 5
  fi
}

_lobash.0_1_0_3385_13492_check_shell() {
  if [[ -z ${BASH_VERSION:-} ]] && [[ -z ${ZSH_VERSION:-} ]]; then
    echo 'Lobash only work in Bash and Zsh.' >&2
    return 5
  fi
}

_lobash.0_1_0_3385_13492_check_shell

_lobash.0_1_0_3385_13492_dirname() {
  local str=$1
  [[ $str == '/' ]] && echo '/' && return 0
  [[ $str =~ ^'../' ]] && echo '.' && return 0
  [[ ! $str =~ / ]] && echo '.' && return 0

  printf '%s\n' "${str%/*}"
}

_lobash.0_1_0_3385_13492_detect_os() {
  local kernel_name
  kernel_name="$(uname -s)"

  case "$kernel_name" in
    "Darwin")                         echo MacOS ;;
    "SunOS")                          echo Solaris ;;
    "Haiku")                          echo Haiku ;;
    "MINIX")                          echo MINIX ;;
    "AIX")                            echo AIX ;;
    "IRIX"*)                          echo IRIX ;;
    "FreeMiNT")                       echo FreeMiNT ;;
    "Linux" | "GNU"*)                 echo Linux ;;
    *"BSD" | "DragonFly" | "Bitrig")  echo BSD ;;
    "CYGWIN"* | "MSYS"* | "MINGW"*)   echo Windows ;;
    *)                                echo Unknown_OS "$kernel_name" ;;
  esac
}

# ---
# Dependent_Internal: detect_os
# ---

# Prevent multiple executions
[[ -n ${_LOBASH_INTERNAL_FUNC_PREFIX:-} ]] && return

readonly _LOBASH_INTERNAL_FUNC_PREFIX=_lobash.
readonly _LOBASH_INTERNAL_CONST_PREFIX=_lobash_
readonly _LOBASH_PRIVATE_FUNC_PREFIX=_l.
readonly _LOBASH_PRIVATE_CONST_PREFIX=_l_
readonly _LOBASH_PUBLIC_FUNC_PREFIX=l.
readonly _LOBASH_PUBLIC_CONST_PREFIX=l_
readonly _LOBASH_DEFAULT_PREFIX=l.

readonly _lobash_0_1_0_3385_13492_os=$(_lobash.0_1_0_3385_13492_detect_os)

######################## Private Methods ########################

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_array_include <array_name> <match>
# ---

l.0_1_0_3385_13492_array_include() {
  local -n l._array_include_arg_array=$1
  local match="$2"
  local e
  shift
  for e in "${l._array_include_arg_array[@]}"; do
    [[ "$e" == "$match" ]] && echo true && return 0;
  done

  echo false
}

# ---
# Category: Prompt
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_ask <message> [<default>=Y]
# Description: Print a message and read Yes/No answer from stdin.
# Description: when default=Y, if will return YES by default.
# Description: when default=N, if will return NO by default.
# ---

l.0_1_0_3385_13492_ask() {
  local msg=$1
  local default=${2:-Y}
  local prompt
  if [[ $default == Y ]]; then
    default=YES
    prompt='([Y]es/No)'
  elif [[ $default == N ]]; then
    default=NO
    prompt='(Yes/[N]o)'
  else
    echo "Invalid argument 'default'. Valid value is 'Y' and 'N'. Current=${default}" >&2
    return 3
  fi

  read -rp "$msg $prompt " answer
  if [[ $answer =~ ^[Yy][Ee]?[Ss]?$ ]]; then
    echo YES
  elif [[ $answer =~ ^[Nn][Oo]?$ ]]; then
    echo NO
  elif [[ $answer == '' ]]; then
    echo "$default"
  else
    echo 'Invalid Answer'
  fi

  return 0
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_basename <path>
# Usage: echo <path> | l.0_1_0_3385_13492_basename
# Description: Alternative to basename command. It much faster because using shell parameter expansion.
# ---

l.0_1_0_3385_13492_basename() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  : "${str%/}"
  printf '%s\n' "${_##*/}"
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_benchmark <command> [<repeats>=10]
# Description: Run command in repeats to get benchmarks.
# ---

_l.0_1_0_3385_13492_run_benchmark() {
  local c=$1
  local repeats=$2

  # Run the given command [repeats] times
  for (( i = 1; i <= "$repeats" ; i++ )); do
    $c > /dev/null 2>&1
  done;
}

l.0_1_0_3385_13492_benchmark() {
  local c=$1
  local repeats=${2:-10}

  echo "Benchmarking: Run command '$c' [$repeats] times.";
  echo "============="
  type "$c"
  echo "============="

  time _l.0_1_0_3385_13492_run_benchmark "$c" "$repeats"

  printf '\n--------------------------\n\n'
}

# ---
# Category: Prompt
# Since: 0.1.0
# Dependent: is_integer
# Usage: l.0_1_0_3385_13492_choose <item>...
# Description: Prompt user to choose one item from options. The function will return the value of chosen item.
# ---

l.0_1_0_3385_13492_choose() {
  local items=("$@")

  printf -- '  %s\n' 'No. Item' >/dev/tty
  local i
  for i in "${!items[@]}"; do
    printf -- '- %-2d  %s\n' $(("$i" + 1)) "${items[$i]}" >/dev/tty
  done

  read -r -p "Please enter the number to choose: " num

  local r
  r=$(l.0_1_0_3385_13492_is_integer "$num")
  [[ $r == false ]] && echo "Must enter an integer. Current: $num">&2 && return 3

  if [[ $num -gt ${#items[@]} ]] || [[ $num -lt 1 ]]; then
   printf '%s\n' "Invalid choose number: $num" >&2
   return 4
  fi

  printf '%s\n' "${items[$((num - 1))]}"
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_compose [<function_name_or_string>]...
# Description: Function composition
# ---

l.0_1_0_3385_13492_compose() {
  local -a last=()
  for f in "$@"; do
    if [[ $(type -t "$f") == function ]]; then
      last=( "$($f "${last[@]}")" )
    else
      last=( "$f" )
    fi
  done
  printf '%s\n' "${last[@]}"
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_count_file_lines <filepath>
# ---

# readarray slow than wc
# l.0_1_0_3385_13492_count_file_lines() {
#   # readarray supported since bash 4.0
#   readarray -tn 0 lines < "$1"
#   printf '%s\n' "${#lines[@]}"
# }

l.0_1_0_3385_13492_count_file_lines() {
  wc -l < "$1" | tr -d ' '
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_count_files <directory_path>
# ---

l.0_1_0_3385_13492_count_files() {
  local files
  # compgen will return 1 when no matched files
  files=( $(compgen -f "$1"/ || [[ $? == 1 ]]) )
  printf '%s\n' "${#files[@]}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_count_lines <string>
# Usage: echo <string> | l.0_1_0_3385_13492_count_lines
# Description: The command and process substitution always trim blank line. So l.0_1_0_3385_13492_count_lines do not accept normal parameter passing.
# Description: Refer to https://stackoverflow.com/a/37706905
# ---

l.0_1_0_3385_13492_count_lines() {
  local count=0
  if [[ -t 0 ]]; then
    [[ -z ${1:-} ]] && printf '0\n' && return 0
    wc -l <<< "$1" | tr -d ' '
  else
    while read -r -d $'\n' _; do
      ((count+=1))
    done
    printf '%s\n' "$count"
  fi
}

# ---
# Category: Variable
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_cur_function_name
# ---

l.0_1_0_3385_13492_cur_function_name() {
  printf '%s\n' "${FUNCNAME[1]}"
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_cursor_col
# Description: get column number of current cursor position
# ---

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_3385_13492_cursor_col() {
  local COL
  IFS=';' read -rsdR -p $'\E[6n' _ COL
  echo "${COL}"
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_cursor_pos
# Usage: IFS=';' c_pos=( $(l.0_1_0_3385_13492_cursor_pos) )
# Description: get current cursor position. It will print "row;column" with default IFS.
# ---

# l.0_1_0_3385_13492_cursor_pos() {
#   stty size
# }

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_3385_13492_cursor_pos() {
  local CURPOS
  read -rsdR -p $'\E[6n' CURPOS
  CURPOS=${CURPOS#*[} # Strip decoration characters <ESC>[
  echo "${CURPOS}"    # Return position in "row;col" format
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_cursor_row
# Description: get row number of current cursor position
# ---

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_3385_13492_cursor_row() {
  local ROW
  IFS=';' read -rsdR -p $'\E[6n' ROW _
  # Strip decoration characters <ESC>[
  echo "${ROW#*[}"
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_date [<format>=]
# Description: Refer to 'man strftime' for <format>.
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#get-the-current-date-using-strftime
l.0_1_0_3385_13492_date() {
  # %(datefmt)T : Causes printf to output the date-time string resulting from using datefmt as a
  # format string for strftime(3). The corresponding argument is an integer representing the number
  # of seconds since the epoch. Two special argument values may be used: -1 represents the
  # current time, and -2 represents the time the shell was invoked. If no argument is specified,
  # conversion behaves as if -1 had been given. This is an exception to the usual printf behavior.
  printf "%($1)T\\n" "-1"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_detect_os
# ---

l.0_1_0_3385_13492_detect_os() {
  _lobash_0_1_0_3385_13492_detect_os
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_dirname <path>
# Usage: echo <path> | l.0_1_0_3385_13492_dirname
# Description: Alternative to dirname command. It much faster because using shell parameter expansion.
# ---

l.0_1_0_3385_13492_dirname() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  _lobash.0_1_0_3385_13492_dirname "$str"
}

# ---
# Category: Console
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_echo <string>...
# Description: A safe way to echo string. Not support any options.
# Description: The builtin echo will get unexpected result while execute `b=( -n 123 ); echo "${b[@]}"`.
# Description: See https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md#echo--printf
# ---

l.0_1_0_3385_13492_echo() {
  printf -- '%b\n' "$*"
}

# ---
# Category: Console
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_echo_array <array_name>
# Description: print each values of array with newline.
# ---

l.0_1_0_3385_13492_echo_array() {
  local -n l._echo_array_arg1=$1
  printf '%s\n' "${l._echo_array_arg1[@]}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_end_with <string> <match>
# ---

l.0_1_0_3385_13492_end_with() {
  [[ ${1%%"$2"}$2 == "$1" ]] && echo true || echo false
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_extname <string>
# Usage: echo <string> | l.0_1_0_3385_13492_extname
# ---

l.0_1_0_3385_13492_extname() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  [[ $str =~ ^\. ]] && echo '' && return
  [[ ! $str =~ \. ]] && echo '' && return
  echo ".${str##*.}"
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_first <array_name>
# Description: It will return the value of arg1.
# ---

l.0_1_0_3385_13492_first() {
  local -n l._first_arg1=$1
  printf '%s\n' "${l._first_arg1[@]:0:1}"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_has <condition> <what>
# Usage: l.0_1_0_3385_13492_has not <condition> <what>
# Description: Exit with 0 or 1. Check if command/function/alias/keyword/builtin or anything existed.
# Description: <condition>  Valid value: `command`, `function`, `alias`, `keyword`, `builtin`, `the`
# Description: This method is not recommended. Use strict_has instead.
# ---

# Reference: https://github.com/qzb/is.sh/blob/master/is.sh
l.0_1_0_3385_13492_has() {
  local condition="$1"
  local value="$2"

  if [[ "$condition" == "not" ]]; then
    shift 1

    local e=false
    [[ $- =~ e ]] && e=true
    set +e
    l.0_1_0_3385_13492_has "${@}"
    local result=$?
    [[ $e == true ]] && set -e

    if [[ $result == 0 ]]; then
      return 1
    elif [[ $result == 1 ]]; then
      return 0
    else
      return $result
    fi
  fi

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && return 0;;
    function)
      [[ $(type -t "$value") == function ]] && return 0;;
    alias)
      [[ $(type -t "$value") == alias ]] && return 0;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && return 0;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && return 0;;
    the)
      type -t "$value"
      return $?;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac > /dev/null

  return 1
}

# ---
# Category: Color
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_hex_to_rgb <HEX>
# Description: Return a list contains <R> <G> <B>.
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#convert-a-hex-color-to-rgb
l.0_1_0_3385_13492_hex_to_rgb() {
  local hex r g b
  hex="${1/\#}"

  if (( ${#hex} == 6 )); then
    ((r=16#${hex:0:2},g=16#${hex:2:2},b=16#${hex:4:2})) || true
  elif (( ${#hex} == 3 )); then
    ((r=16#${hex:0:1}${hex:0:1},g=16#${hex:1:1}${hex:1:1},b=16#${hex:2:1}${hex:2:1})) || true
  else
    echo 'Argument is not a hex.' >&2
    return 3
  fi

  printf '%s\n%s\n%s\n' "$r" "$g" "$b"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_hostname
# ---

l.0_1_0_3385_13492_hostname() {
  printf '%s\n' "${HOSTNAME:-$(hostname)}"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_if <condition> <then> [<else>]
# Description: The difference from shell builtin `if` is when condition function throw exception it will ended immediately.
# Description: <condition> can be function name, string and number. The function should return `true`/`0` or `false`/`1`.
# Description: <then> and <else> must be function name. And <else> is optional.
# Description: When <condition> is true, <then> function will be invoked. Otherwise <else> will be invoked if it passed.
# ---

l.0_1_0_3385_13492_if() {
  local condition
  if [[ $(type -t "$1") == function ]]; then
    condition=$($1)
  else
    condition=$1
  fi

  if [[ $condition == true ]] || [[ $condition == 0 ]]; then
    $2
  elif [[ $condition == false ]] || [[ $condition == 1 ]]; then
    ${3:-}
  else
    echo "Invalid condition: $condition"
    return 3
  fi
}

# ---
# Category: Arithmetic
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_inc <var_name> [<addend>=1]
# Description: Increase number with addend.
# ---

l.0_1_0_3385_13492_inc() {
  local -n l._inc_arg1=$1
  ((l._inc_arg1+=${2:-1})) || true
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_array <var_name>
# ---

l.0_1_0_3385_13492_is_array() {
  [[ -z ${1:-} ]] && echo false && return 0

  local str
  str=$(declare -p -- "$1" 2>/dev/null || true)
  [[ -z $str ]] && echo false && return 0

  local start="declare -a "
  [[ $start${str##"$start"} == "$str" ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_bash
# ---

l.0_1_0_3385_13492_is_bash() {
  [[ -n "$BASH_VERSION" ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_dir <var>
# ---

l.0_1_0_3385_13492_is_dir() {
  [[ -d $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_executable <var>
# Description: Similar to `[[ -x ]]`. Return `true` or `false`.
# ---

l.0_1_0_3385_13492_is_executable() {
  [[ -x $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Dependent: is_dir
# Usage: l.0_1_0_3385_13492_is_executable_file <var>
# Description: Similar to `l.0_1_0_3385_13492_is_executable`. But directory will return false.
# ---

l.0_1_0_3385_13492_is_executable_file() {
  local r
  r=$(l.0_1_0_3385_13492_is_dir "$1")
  if [[ $r == true ]]; then
    # directory is executable
    # https://superuser.com/a/168583
    echo false
  else
    [[ -x $1 ]] && echo true || echo false
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Dependent: is_integer
# Usage: l.0_1_0_3385_13492_is_false <var>
# ---

l.0_1_0_3385_13492_is_false() {
  local r
  r=$(l.0_1_0_3385_13492_is_integer "$1")

  if [[ $r == true ]]; then
    if [[ $1 != 0 ]]; then
      echo true
    else
      echo false
    fi
  else
    if [[ $1 == false ]]; then
      echo true
    else
      echo false
    fi
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_file <var>
# ---

l.0_1_0_3385_13492_is_file() {
  [[ -f $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_float <str>
# ---

l.0_1_0_3385_13492_is_float() {
  [[ $1 =~ ^[-+]?[0-9]+([.][0-9]+)?$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_integer <str>
# ---

l.0_1_0_3385_13492_is_integer() {
  [[ $1 =~ ^[-+]?[0-9]+$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_link <var>
# ---

l.0_1_0_3385_13492_is_link() {
  [[ -L $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_number <str>
# ---

l.0_1_0_3385_13492_is_number() {
  [[ $1 =~ ^[-+]?[0-9]+(.[0-9]+)?$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_readable <var>
# ---

l.0_1_0_3385_13492_is_readable() {
  [[ -r $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_true <var>
# ---

l.0_1_0_3385_13492_is_true() {
  if [[ $1 == true ]] || [[ $1 == 0 ]]; then
    echo true
  else
    echo false
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_writeable <var>
# ---

l.0_1_0_3385_13492_is_writeable() {
  [[ -w $1 ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_is_zsh
# ---

l.0_1_0_3385_13492_is_zsh() {
  [[ -n "$ZSH_VERSION" ]] && echo true || echo false
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_join <array_name> [<delimiter>=,]
# Description: Convert all elements in array into a string separated by delimiter.
# ---

l.0_1_0_3385_13492_join() {
  local -n l._join_arg1=$1
  local _IFS=$IFS
  if [[ $# == 1 ]]; then
    IFS=,
  else
    IFS=${2}
  fi
  printf '%s\n' "${l._join_arg1[*]}"
  IFS=$_IFS
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_last <array_name>
# Description: It will return the value of argN.
# ---

l.0_1_0_3385_13492_last() {
  local -n l._last_arg1=$1
  printf '%s\n' "${l._last_arg1[@]: -1:1}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_lower_case <string>
# Usage: echo <string> | l.0_1_0_3385_13492_lower_case
# Description: Convert all characters of string to lower case.
# ---

# l.0_1_0_3385_13492_lower_case() {
#   tr '[:upper:]' '[:lower:]' <<< ${1:-}
# }

# CAVEAT: Requires bash 4+
l.0_1_0_3385_13492_lower_case() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  printf '%s\n' "${str,,}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_lower_first <string>
# Usage: echo <string> | l.0_1_0_3385_13492_lower_first
# Description: Convert the first character of string to lower case.
# ---

# CAVEAT: Requires bash 4+
l.0_1_0_3385_13492_lower_first() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  printf '%s\n' "${str,}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_match "string" "regex" [index=1]
# Description: Return matched part of string. Return empty string if no matched. Support capturing groups.
# ---

l.0_1_0_3385_13492_match() {
  [[ ${3:-} == 0 ]] && echo "index cannot be 0" >&2 && return 3

  if [[ $1 =~ $2 ]]; then
    if (( ${#BASH_REMATCH[@]} > 1 )); then
      printf '%s\n' "${BASH_REMATCH[${3:-1}]}"
    else
      echo ''
    fi
  else
    echo ''
  fi
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_normalize <path>
# Usage: echo <path> | l.0_1_0_3385_13492_normalize
# Dependent: split, join
# Description: Normalize the given path which can be an unexisted path.
# Description: Trailing `/` always be removed.
# ---

l.0_1_0_3385_13492_normalize() {
  local path
  if [[ -t 0 ]]; then
    path=${1:-}
  else
    IFS='' read -r path
  fi

  if [[ -z ${path} ]]; then
    echo '.'
    return 0
  fi

  if [[ ${path} == '.' ]]; then
    echo '.'
    return 0
  fi

  local -a words
  l.0_1_0_3385_13492_split "$path" words '/'
  local -a list=()
  local -a pre_list=()
  local n=0
  local i

  if [[ ${path:0:1} == '/' ]]; then
    pre_list+=(/)
  else
    for i in "${words[@]}"; do
      if [[ $i =~ ^'.' ]]; then
        ((n+=1))
        pre_list+=("$i")
      else
        break
      fi
    done
  fi

  for (( ; n < ${#words[@]}; n++ )); do
    i=${words[$n]}
    if [[ $i == '' ]] || [[ $i == '.' ]]; then
      true
    elif [[ $i == '..' ]]; then
      local k=$(( ${#list[@]} - 1)) || true
      [[ $k > -1 ]] && unset list["$k"]
    else
      list+=("$i")
    fi
  done

  printf '%s%s\n' "$(l.0_1_0_3385_13492_join pre_list '/')" "$(l.0_1_0_3385_13492_join list '/')"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_not <condition>
# Description: <condition> must be `true` or `false`. This function returns the opposite value.
# ---

l.0_1_0_3385_13492_not() {
  if [[ -t 0 ]]; then
    local condition="${1:-}"
  else
    read -r condition
  fi

  if [[ $condition == true ]]; then
    echo false;
  elif [[ $condition == false ]]; then
    echo true
  else
    echo "Invalid condition! It must be one of 'true' and 'false'. Current value=$condition" >&2
    return 3
  fi
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_now
# Description: Print the timestamp of the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
# ---

l.0_1_0_3385_13492_now() {
  # +%N not supported in MacOS.
  # date '+%s%3N'

  # Perl is ubiquitous.
  perl -MTime::HiRes=time -e 'printf "%d\n", time * 1000'
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_now_s
# Description: Print the timestamp of the number of seconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
# Dependent: date
# ---

l.0_1_0_3385_13492_now_s() {
  l.0_1_0_3385_13492_date '%s'
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_pwd
# Description: Return the current working directory as set by the cd builtin.
# ---

l.0_1_0_3385_13492_pwd() {
  printf '%s\n' "$PWD"
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_random [<length>=10] [<pattern>=a-zA-Z0-9@#*=[]]
# Description: Return a random string in specific length.
# Description: The <pattern> is allowed characters in range.
# ---

l.0_1_0_3385_13492_random() {
  local length=${1:-10}
  local pattern=${2:-a-zA-Z0-9@#*=[]}
  printf '%s\n' "$(LC_CTYPE=C tr -dc "$pattern" < /dev/urandom | head -c "$length")"
}

# ---
# Category: Path
# Since: 0.1.0
# Dependent: normalize
# Usage: l.0_1_0_3385_13492_relative <path1> <path2>
# ---

l.0_1_0_3385_13492_relative() {
  echo 'todo'
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_repeat <N> <command_name> [<command_args>]...
# Description: Execute command in N times.
# ---

l.0_1_0_3385_13492_repeat() {
  local -i n=$1
  (( n == 0 )) && return
  (( n < 0 )) && return

  shift
  for n in $(seq "$n"); do
    "$@"
  done
}

# ---
# Category: Color
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_rgb_to_hex <R> <G> <B>
# Dependent: is_number
# Description: Return hex string. Like '#ffffff'
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#convert-an-rgb-color-to-hex
l.0_1_0_3385_13492_rgb_to_hex() {
  if (( $# != 3 )); then
    echo 'The arguments size not equal 3' >&2
    return 3
  fi

  if [[ $(l.0_1_0_3385_13492_is_number "$1") == false ]]; then
    echo 'The first argument is not a number' >&2
    return 4
  fi

  if [[ $(l.0_1_0_3385_13492_is_number "$2") == false ]]; then
    echo 'The second argument is not a number' >&2
    return 5
  fi

  if [[ $(l.0_1_0_3385_13492_is_number "$3") == false ]]; then
    echo 'The third argument is not a number' >&2
    return 6
  fi

  printf '#%02x%02x%02x\n' "$1" "$2" "$3"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_sleep <number_or_float>
# Description: Same to sleep command but support float.
# Description: When run it in Linux/Unix System, the precision of sleep time is 1ms. The deviation of sleep time is 1~2ms by actual measurement.
# Description: When run it in MacOS, the precision of sleep time is 100ms. The deviation of sleep time is 30~40ms by actual measurement.
# ---

# This way is accurate but has bug. Sleep can be cancelled when stdin get 99999 characters in time.
# l.0_1_0_3385_13492_sleep() {
#   read -rst "${1:-1}" -N 99999 || true
# }

# MacOS will show shows "/dev/fd/62: Permission denied" on `exec {_sleep_fd}<> <(true)`. So we make a workaround.
if [[ $OSTYPE =~ darwin ]]; then
  _l_0_1_0_3385_13492_sleep_temp=$(mktemp -u)
  # Create a FIFO special file
  mkfifo -m 700 "$_l_0_1_0_3385_13492_sleep_temp"
fi

# Refer to below links
# - https://blog.dhampir.no/content/sleeping-without-a-subprocess-in-bash-and-how-to-sleep-forever
# - https://bash.cyberciti.biz/guide/Opening_the_file_descriptors_for_reading_and_writing
# - https://bash.cyberciti.biz/guide/Closes_the_file_descriptor_(fd)
# - https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)
l.0_1_0_3385_13492_sleep() {
  # Reset IFS in case itâ€™s set to something weird.
  local IFS
  local _sleep_fd

  if [[ $OSTYPE =~ darwin ]]; then
    # MacOS will show shows "/dev/fd/62: Permission denied" on `exec {_sleep_fd}<> <(true)`. So we make a workaround.

    # local _l_0_1_0_3385_13492_sleep_temp
    # Get available temp file path
    # _l_0_1_0_3385_13492_sleep_temp=$(mktemp -u)
    # # Create a FIFO special file
    # mkfifo -m 700 "$_l_0_1_0_3385_13492_sleep_temp"
    exec {_sleep_fd}<>"$_l_0_1_0_3385_13492_sleep_temp"
    # rm -f "$_l_0_1_0_3385_13492_sleep_temp"
  else
    exec {_sleep_fd}<> <(true)
  fi

  # Wait for timeout
  read -rst "${1:-1}" -u "$_sleep_fd" || true
  # Close fd
  exec {_sleep_fd}<&-
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_sort <array_name> [<sort-opts>]...
# Description: Sort an array. The <sort-opts> are options of sort command.
# ---

l.0_1_0_3385_13492_sort() {
  local -n l._sort_arg1=$1
  shift
  printf '%s\n' "${l._sort_arg1[@]}" | sort "$@"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_split <string> <output_array_name> [<delimiter>=' ']
# Description: Splits string by delimiter. The result will be assigned to <output_array_name>.
# ---

_l.0_1_0_3385_13492_split() {
  local -i i

  local dLen=${#delimiter}
  local sLen=${#string}

  if [[ $delimiter == '' ]]; then
    for (( i=0; i < sLen; i++ )); do
      printf '%s\n' "${string:$i:1}"
    done
    return 0
  fi

  local -a indexes=()
  local -i a=0 b=0 d

  while (( a < "$sLen" )); do
    for (( b=a+1; b <= sLen; b++ )); do
      d=$(( b - a )) || true
      if (( d > dLen )); then
        break;
      fi

      if [[ "${string:$a:$d}" == "$delimiter" ]]; then
        indexes+=("$a")
      fi
    done
    (( a++ )) || true
  done

  a=0
  for i in "${indexes[@]}"; do
    printf '%s\n' "${string:$a:$(( i - a ))}"
    a=$((i + dLen));
  done

  if (( a + dLen - 1 == sLen )); then
    printf '\n'
  elif (( a < sLen )); then
    printf '%s\n' "${string:$a}"
  fi
}

l.0_1_0_3385_13492_split() {
  local string=$1
  local output=$2
  local delimiter
  if [[ $# == 2 ]]; then
    delimiter=' '
  else
    delimiter="${3}"
  fi

  IFS=$'\n' readarray -t "$output" < <(_l.0_1_0_3385_13492_split)
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_start_with <string> <match>
# Description: Return `true` or `false`. Check if a string starts with given match string.
# ---

l.0_1_0_3385_13492_start_with() {
  [[ $2${1##"$2"} == "$1" ]] && echo true || echo false
}

# ---
# Category: String
# Since: 0.1.0
# Usage: str_include <string> <sub-string>
# Description: Return `true` or `false`. Check if a string includes given match string.
# ---

# shellcheck disable=SC2076

l.0_1_0_3385_13492_str_include() {
  [[ "$1" =~ "$2" ]] && echo true || echo false;
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_str_len <string>
# Description: Return the byte length of string.
# ---

l.0_1_0_3385_13492_str_len() {
  local oLang oLcAll bytlen
  [[ -n ${LC_ALL:-} ]] && oLcAll=$LC_ALL
  [[ -n ${LANG:-} ]] && oLang=$LANG

  LANG=C LC_ALL=C
  bytlen=${#1}

  [[ -n ${oLang:-} ]] && LANG=$oLang
  [[ -n ${oLcAll:-} ]] && LC_ALL=$oLcAll

  printf -- '%s\n' "$bytlen"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_str_size <string>
# Description: Return the sum of string letters.
# ---

l.0_1_0_3385_13492_str_size() {
  printf -- '%s\n' "${#1}"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_strict_has <condition> <what>
# Description: Return `true` or `false`. Check if command/function/alias/keyword/builtin or anything existed.
# Description: <condition>  Valid value: `command`, `function`, `alias`, `keyword`, `builtin`, `the`
# ---

l.0_1_0_3385_13492_strict_has() {
  local condition="$1"
  local value="$2"

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && echo true || echo false;;
    function)
      [[ $(type -t "$value") == function ]] && echo true || echo false;;
    alias)
      [[ $(type -t "$value") == alias ]] && echo true || echo false;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && echo true || echo false;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && echo true || echo false;;
    the)
      type -t "$value" >/dev/null && echo true || echo false;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: strict_has_not <condition> <what>
# Dependent: strict_has, not
# Description: Opposite to strict_has.
# ---

l.0_1_0_3385_13492_strict_has_not() {
  local r
  r=$(l.0_1_0_3385_13492_strict_has "$@")
  l.0_1_0_3385_13492_not "$r"
}

# ---
# Category: Arithmetic
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_sub <var_name> [<subtrahend>=1]
# Description: Subtract number with subtrahend.
# ---

l.0_1_0_3385_13492_sub() {
  local -n l._sub_arg1=$1
  ((l._sub_arg1-=${2:-1})) || true
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trace_count [<label>=trace]
# Description: It prints a count which increased after each called.
# Description: Attention: l.0_1_0_3385_13492_trace_count should run in same process. It will not work in subprocess such as $(l.0_1_0_3385_13492_trace_count)
# ---

l.0_1_0_3385_13492_trace_count() {
  local label=${1:-trace}
  local key=_LOBASH_trace_count_$label

  if [[ -z ${!key:-} ]]; then
    declare -g "$key"=0
  fi

  read -r "$key" <<< $(( ${!key} + 1 ))

  printf '[%s] count: %s\n' "$label" "${!key}"
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trace_end
# Description: Close xtrace mode and reset PS4. Cooperated with trace_start.
# ---

l.0_1_0_3385_13492_trace_end() {
  set +o xtrace
  PS4=${_l_0_1_0_3385_13492_trace_start_old_ps4:-$PS4}
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trace_stack [label]
# Description: Print current function stack for debug.
# ---

l.0_1_0_3385_13492_trace_stack() {
  printf 'Trace Function Stack:%s\n  # Function (File:Line)\n' "${1:+ $1}"
  for i in $(seq 1 $(( ${#BASH_SOURCE[@]} -1 ))); do
    printf -- '  - %s (%s:%s)\n' "${FUNCNAME[$i]}" "${BASH_SOURCE[$i]}" "${BASH_LINENO[$i]}"
  done
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trace_start [<PS4_level>=2] [<label>]
# Description: PS4_level  Valid Values: `1`, `2`, `3`. Different level changes different prompt message format.
# Description: Open xtrace mode and set PS4. It will print each script line with nice prompt for debug.
# ---
# shellcheck disable=SC2034

l.0_1_0_3385_13492_trace_start() {
  _l_0_1_0_3385_13492_trace_start_old_ps4=$PS4
  local label=${2:-}
  [[ -n "$label" ]] && label="[$label]"

  case ${1:-2} in
    1 )
      PS4='+'${label}'[${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    2 )
      PS4='+'${label}'[$(basename ${BASH_SOURCE[0]}):${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    3 )
      PS4='+'${label}'[${BASH_SOURCE[0]}:${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    * )
      echo "Invalid PS4_LEVEL: $1" >&2
      return 3
      ;;
  esac

  set -o xtrace
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trace_time [label]
# Dependent: now
# Description: Print current timestamp, last timestamp and the elapsed time in millisecond.
# ---

l.0_1_0_3385_13492_trace_time() {
  local label=${1:-debug}
  local key=_LOBASH_TRACE_TIME_$label
  local last_time=${!key:-}
  local current
  current="$(l.0_1_0_3385_13492_now)"

  printf '[%s] Current Timestamp: %s\n' "$label" "$current"

  if [[ -n $last_time ]]; then
    printf '[%s] Last Timestamp: %s\n[%s] Elapsed: %s\n' "$label" "$last_time" "$label" $(( "$(l.0_1_0_3385_13492_now)" - "$last_time" ))
    read -r "$key" <<< "$current"
  else
    declare -g "$key"="$current"
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Dependent: trim_start, trim_end
# Usage: l.0_1_0_3385_13492_trim <string>
# Usage: echo <string> | l.0_1_0_3385_13492_trim
# Description: Remove leading and trailing whitespace from string.
# ---

l.0_1_0_3385_13492_trim() {
  if [[ -t 0 ]]; then
    l.0_1_0_3385_13492_trim_start "${1:-}" | l.0_1_0_3385_13492_trim_end
  else
    read -r str
    l.0_1_0_3385_13492_trim_start <<< "$str" | l.0_1_0_3385_13492_trim_end
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trim_color <string>
# Usage: echo <string> | l.0_1_0_3385_13492_trim_color
# Description: Remove color escape code in string
# ---

l.0_1_0_3385_13492_trim_color() {
  local ecs=$'\e'
  local str

  if [[ -t 0 ]]; then
    str="$1"
  else
    read -r str
  fi

  if [[ $_lobash_0_1_0_3385_13492_os == Linux ]]; then
    sed -E "s,${ecs}[[0-9]*(;[0-9]+)*m,,g" <<< "$str"
  elif [[ $_lobash_0_1_0_3385_13492_os == MacOS ]] || [[ $_lobash_0_1_0_3385_13492_os == BSD ]]; then
    sed -E "s,\\${ecs}[[0-9]*(;[0-9]+)*m,,g" <<< "$str"
  else
    echo "Only MacOS/BSD/Linux systems are valid." >&2
    return 5
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trim_end <string> [chars=[[:space:]]]
# Usage: echo <string> | l.0_1_0_3385_13492_trim_end [chars=[[:space:]]]
# Description: Remove trailing whitespace or specified characters from string.
# ---

l.0_1_0_3385_13492_trim_end() {
  if [[ -t 0 ]]; then
    local str=${1:-}
    if [[ $# == 2 ]]; then
      printf '%s\n' "${str%%$2}"
    else
      # https://stackoverflow.com/a/3352015
      printf '%s\n' "${str%"${str##*[![:space:]]}"}"
    fi
  else
    IFS='' read -r str
    if [[ $# == 1 ]]; then
      printf '%s\n' "${str%%$1}"
    else
      printf '%s\n' "${str%"${str##*[![:space:]]}"}"
    fi
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_trim_start <string>
# Usage: echo <string> | l.0_1_0_3385_13492_trim_start
# Description: Remove leading whitespace or specified characters from string.
# ---

l.0_1_0_3385_13492_trim_start() {
  if [[ -t 0 ]]; then
    local str=${1:-}
    if [[ $# == 2 ]]; then
      printf '%s\n' "${str##$2}"
    else
      # https://stackoverflow.com/a/3352015
      printf '%s\n' "${str#"${str%%[![:space:]]*}"}"
    fi
  else
    IFS='' read -r str
    if [[ $# == 1 ]]; then
      printf '%s\n' "${str##$1}"
    else
      printf '%s\n' "${str#"${str%%[![:space:]]*}"}"
    fi
  fi
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_union_array <array_name>...
# Dependent: echo_array
# Description: Create an array of unique values from all given arrays.
# ---

l.0_1_0_3385_13492_union_array() {
  local -n l._union_array_a=$1
  local -n l._union_array_b=$2
  local -a arr
  arr=("${l._union_array_a[@]}" "${l._union_array_b[@]}")
  l.0_1_0_3385_13492_echo_array arr
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_upper_case <string>
# Usage: echo <string> | l.0_1_0_3385_13492_upper_case
# Description: Convert all characters of string to upper case.
# ---

# l.0_1_0_3385_13492_upper_case() {
#   tr '[:lower:]' '[:upper:]' <<< ${1:-}
# }

# CAVEAT: Requires bash 4+
l.0_1_0_3385_13492_upper_case() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi
  printf '%s\n' "${str^^}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_upper_first <string>
# Usage: echo <string> | l.0_1_0_3385_13492_upper_first
# Description: Convert the first character of string to upper case.
# ---

# CAVEAT: Requires bash 4+
l.0_1_0_3385_13492_upper_first() {
  local str
  if [[ -t 0 ]]; then
    str=$1
  else
    IFS='' read -r str
  fi

  printf '%s\n' "${str^}"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_3385_13492_xdg_config_home
# Description: Return XDG_CONFIG_HOME. Return `${HOME}/.config` if XDG_CONFIG_HOME not set.
# ---

l.0_1_0_3385_13492_xdg_config_home() {
  printf '%s\n' "${XDG_CONFIG_HOME:-${HOME}/.config}"
}

######################## Public Methods ########################
l.end_with() { l.0_1_0_3385_13492_end_with "$@"; }
l.trim_color() { l.0_1_0_3385_13492_trim_color "$@"; }
l.lower_first() { l.0_1_0_3385_13492_lower_first "$@"; }
l.has() { l.0_1_0_3385_13492_has "$@"; }
l.is_integer() { l.0_1_0_3385_13492_is_integer "$@"; }
l.sort() { l.0_1_0_3385_13492_sort "$@"; }
l.join() { l.0_1_0_3385_13492_join "$@"; }
l.is_number() { l.0_1_0_3385_13492_is_number "$@"; }
l.is_link() { l.0_1_0_3385_13492_is_link "$@"; }
l.echo_array() { l.0_1_0_3385_13492_echo_array "$@"; }
l.now() { l.0_1_0_3385_13492_now "$@"; }
l.is_false() { l.0_1_0_3385_13492_is_false "$@"; }
l.trim_end() { l.0_1_0_3385_13492_trim_end "$@"; }
l.split() { l.0_1_0_3385_13492_split "$@"; }
l.is_bash() { l.0_1_0_3385_13492_is_bash "$@"; }
l.last() { l.0_1_0_3385_13492_last "$@"; }
l.union_array() { l.0_1_0_3385_13492_union_array "$@"; }
l.dirname() { l.0_1_0_3385_13492_dirname "$@"; }
l.basename() { l.0_1_0_3385_13492_basename "$@"; }
l.xdg() { l.0_1_0_3385_13492_xdg "$@"; }
l.trace_end() { l.0_1_0_3385_13492_trace_end "$@"; }
l.ask() { l.0_1_0_3385_13492_ask "$@"; }
l.count_lines() { l.0_1_0_3385_13492_count_lines "$@"; }
l.str_size() { l.0_1_0_3385_13492_str_size "$@"; }
l.strict_has() { l.0_1_0_3385_13492_strict_has "$@"; }
l.is_float() { l.0_1_0_3385_13492_is_float "$@"; }
l.hostname() { l.0_1_0_3385_13492_hostname "$@"; }
l.extname() { l.0_1_0_3385_13492_extname "$@"; }
l.is_dir() { l.0_1_0_3385_13492_is_dir "$@"; }
l.is_executable() { l.0_1_0_3385_13492_is_executable "$@"; }
l.cursor_col() { l.0_1_0_3385_13492_cursor_col "$@"; }
l.str_len() { l.0_1_0_3385_13492_str_len "$@"; }
l.repeat() { l.0_1_0_3385_13492_repeat "$@"; }
l.pwd() { l.0_1_0_3385_13492_pwd "$@"; }
l.count_files() { l.0_1_0_3385_13492_count_files "$@"; }
l.trim() { l.0_1_0_3385_13492_trim "$@"; }
l.str_include() { l.0_1_0_3385_13492_str_include "$@"; }
l.cursor_row() { l.0_1_0_3385_13492_cursor_row "$@"; }
l.is_executable_file() { l.0_1_0_3385_13492_is_executable_file "$@"; }
l.trace_stack() { l.0_1_0_3385_13492_trace_stack "$@"; }
l.compose() { l.0_1_0_3385_13492_compose "$@"; }
l.hex_to_rgb() { l.0_1_0_3385_13492_hex_to_rgb "$@"; }
l.trace_time() { l.0_1_0_3385_13492_trace_time "$@"; }
l.sub() { l.0_1_0_3385_13492_sub "$@"; }
l.inc() { l.0_1_0_3385_13492_inc "$@"; }
l.benchmark() { l.0_1_0_3385_13492_benchmark "$@"; }
l.relative() { l.0_1_0_3385_13492_relative "$@"; }
l.is_readable() { l.0_1_0_3385_13492_is_readable "$@"; }
l.is_array() { l.0_1_0_3385_13492_is_array "$@"; }
l.choose() { l.0_1_0_3385_13492_choose "$@"; }
l.is_file() { l.0_1_0_3385_13492_is_file "$@"; }
l.trim_start() { l.0_1_0_3385_13492_trim_start "$@"; }
l.now_s() { l.0_1_0_3385_13492_now_s "$@"; }
l.random() { l.0_1_0_3385_13492_random "$@"; }
l.upper_case() { l.0_1_0_3385_13492_upper_case "$@"; }
l.count_file_lines() { l.0_1_0_3385_13492_count_file_lines "$@"; }
l.sleep() { l.0_1_0_3385_13492_sleep "$@"; }
l.is_writeable() { l.0_1_0_3385_13492_is_writeable "$@"; }
l.match() { l.0_1_0_3385_13492_match "$@"; }
l.cur_function_name() { l.0_1_0_3385_13492_cur_function_name "$@"; }
l.is_zsh() { l.0_1_0_3385_13492_is_zsh "$@"; }
l.is_true() { l.0_1_0_3385_13492_is_true "$@"; }
l.echo() { l.0_1_0_3385_13492_echo "$@"; }
l.strict_has_not() { l.0_1_0_3385_13492_strict_has_not "$@"; }
l.detect_os() { l.0_1_0_3385_13492_detect_os "$@"; }
l.normalize() { l.0_1_0_3385_13492_normalize "$@"; }
l.not() { l.0_1_0_3385_13492_not "$@"; }
l.cursor_pos() { l.0_1_0_3385_13492_cursor_pos "$@"; }
l.trace_count() { l.0_1_0_3385_13492_trace_count "$@"; }
l.first() { l.0_1_0_3385_13492_first "$@"; }
l.rgb_to_hex() { l.0_1_0_3385_13492_rgb_to_hex "$@"; }
l.array_include() { l.0_1_0_3385_13492_array_include "$@"; }
l.trace_start() { l.0_1_0_3385_13492_trace_start "$@"; }
l.lower_case() { l.0_1_0_3385_13492_lower_case "$@"; }
l.if() { l.0_1_0_3385_13492_if "$@"; }
l.start_with() { l.0_1_0_3385_13492_start_with "$@"; }
l.date() { l.0_1_0_3385_13492_date "$@"; }
l.upper_first() { l.0_1_0_3385_13492_upper_first "$@"; }
